<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Ghostty Terminal - File Browser</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        background: linear-gradient(135deg, #1e3c72 0%, #2a5298 100%);
        min-height: 100vh;
        padding: 20px;
        display: flex;
        flex-direction: column;
      }

      .container {
        max-width: 1200px;
        margin: 0 auto;
        width: 100%;
        flex: 1;
        display: flex;
        flex-direction: column;
      }

      header {
        text-align: center;
        color: white;
        margin-bottom: 20px;
      }

      h1 {
        font-size: 2.5rem;
        margin-bottom: 10px;
        text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
      }

      .subtitle {
        opacity: 0.9;
        font-size: 1.1rem;
      }

      .status-bar {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        padding: 15px 20px;
        border-radius: 10px 10px 0 0;
        display: flex;
        justify-content: space-between;
        align-items: center;
        color: white;
      }

      .status-indicator {
        display: flex;
        align-items: center;
        gap: 10px;
      }

      .status-dot {
        width: 12px;
        height: 12px;
        border-radius: 50%;
        background: #ff4444;
        animation: pulse 2s infinite;
      }

      .status-dot.connected {
        background: #44ff44;
      }

      @keyframes pulse {
        0%,
        100% {
          opacity: 1;
        }
        50% {
          opacity: 0.5;
        }
      }

      .terminal-wrapper {
        background: white;
        border-radius: 0 0 10px 10px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        overflow: hidden;
        flex: 1;
        display: flex;
        flex-direction: column;
        min-height: 600px;
      }

      #terminal-container {
        flex: 1;
        padding: 10px;
        background: #1e1e1e;
        position: relative;
      }

      .info-box {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        padding: 15px;
        border-radius: 10px;
        color: white;
        margin-top: 20px;
      }

      .info-box h3 {
        margin-bottom: 10px;
        font-size: 1.2rem;
      }

      .info-box ul {
        list-style: none;
        padding-left: 0;
      }

      .info-box li {
        padding: 5px 0;
        padding-left: 20px;
        position: relative;
      }

      .info-box li:before {
        content: 'â–¸';
        position: absolute;
        left: 0;
        color: #4caf50;
      }

      .warning {
        background: rgba(255, 152, 0, 0.2);
        border-left: 4px solid #ff9800;
        padding: 15px;
        border-radius: 5px;
        color: white;
        margin-top: 20px;
      }

      .warning strong {
        display: block;
        margin-bottom: 5px;
        color: #ffd54f;
      }

      code {
        background: rgba(0, 0, 0, 0.3);
        padding: 2px 6px;
        border-radius: 3px;
        font-family: 'Monaco', 'Menlo', monospace;
        font-size: 0.9em;
      }

      @media (max-width: 768px) {
        h1 {
          font-size: 2rem;
        }

        .status-bar {
          flex-direction: column;
          gap: 10px;
          align-items: flex-start;
        }
      }

      /* Feature Panel */
      .feature-panel {
        background: rgba(255, 255, 255, 0.1);
        backdrop-filter: blur(10px);
        padding: 15px;
        border-radius: 10px;
        color: white;
        margin-top: 20px;
      }

      .feature-panel h3 {
        margin-bottom: 15px;
        font-size: 1.2rem;
      }

      .button-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 10px;
        margin-bottom: 15px;
      }

      .test-button {
        background: rgba(76, 175, 80, 0.8);
        border: none;
        padding: 12px 20px;
        border-radius: 5px;
        color: white;
        cursor: pointer;
        font-size: 14px;
        font-weight: 500;
        transition: all 0.2s;
      }

      .test-button:hover {
        background: rgba(76, 175, 80, 1);
        transform: translateY(-2px);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.3);
      }

      .test-button:active {
        transform: translateY(0);
      }

      .event-log {
        background: rgba(0, 0, 0, 0.3);
        border-radius: 5px;
        padding: 10px;
        max-height: 150px;
        overflow-y: auto;
        font-family: 'Monaco', 'Menlo', monospace;
        font-size: 12px;
      }

      .event-log .event {
        padding: 4px 0;
        border-bottom: 1px solid rgba(255, 255, 255, 0.1);
      }

      .event-log .event:last-child {
        border-bottom: none;
      }

      .event-log .event-type {
        color: #4caf50;
        font-weight: bold;
      }

      .event-log .event-data {
        color: #e0e0e0;
      }

      .clear-log {
        background: rgba(244, 67, 54, 0.8);
        border: none;
        padding: 8px 16px;
        border-radius: 5px;
        color: white;
        cursor: pointer;
        font-size: 12px;
        margin-top: 10px;
      }

      .clear-log:hover {
        background: rgba(244, 67, 54, 1);
      }
    </style>
  </head>
  <body>
    <div class="container">
      <header>
        <h1>ğŸ–¥ï¸ Ghostty Terminal</h1>
        <p class="subtitle">WebAssembly-powered terminal with full filesystem access</p>
      </header>

      <div class="status-bar">
        <div class="status-indicator">
          <div class="status-dot" id="status-dot"></div>
          <span id="status-text">Connecting...</span>
        </div>
        <div>
          <small id="ws-url" style="opacity: 0.7; margin-right: 15px"></small>
          <span id="cwd-display">~/</span>
        </div>
      </div>

      <div class="terminal-wrapper">
        <div id="terminal-container"></div>
      </div>

      <div class="feature-panel">
        <h3>ğŸ¯ xterm.js API Features</h3>
        <div class="button-grid">
          <button class="test-button" id="btn-paste">ğŸ“‹ Test paste()</button>
          <button class="test-button" id="btn-blur">ğŸ‘ï¸ Test blur()</button>
          <button class="test-button" id="btn-input">âŒ¨ï¸ Test input()</button>
          <button class="test-button" id="btn-select">ğŸ”¤ Test select()</button>
          <button class="test-button" id="btn-selectLines">ğŸ“„ Test selectLines()</button>
          <button class="test-button" id="btn-getSelectionPos">ğŸ“ Get Selection Position</button>
          <button class="test-button" id="btn-setTitle">ğŸ·ï¸ Set Title (OSC)</button>
          <button class="test-button" id="btn-customHandler">ğŸ”§ Toggle Custom Handler</button>
        </div>
        <div>
          <strong style="display: block; margin-bottom: 8px"
            >Event Log (onKey, onTitleChange):</strong
          >
          <div class="event-log" id="event-log">
            <div style="opacity: 0.5; text-align: center">Events will appear here...</div>
          </div>
          <button class="clear-log" id="btn-clear-log">Clear Log</button>
        </div>
      </div>

      <div class="warning">
        <strong>âš ï¸ Warning: Full Filesystem Access</strong>
        This demo has unrestricted access to your entire filesystem. It's meant for local
        development and demonstration purposes only. Do not expose this to untrusted users or
        networks.
      </div>
    </div>

    <!-- Import Terminal from lib -->
    <script type="module">
      import { Terminal } from '../lib/index.ts';
      import { FitAddon } from '../lib/addons/fit.ts';

      // =========================================================================
      // Configuration
      // =========================================================================

      // Auto-detect hostname (works for localhost and remote hosts like mux.coder)
      const hostname = window.location.hostname || 'localhost';
      const WS_URL = `ws://${hostname}:3001/ws`;
      let ws = null;
      let term = null;
      let fitAddon = null;
      let currentLine = '';
      let commandHistory = [];
      let historyIndex = -1;
      let currentCwd = '~';
      let isPtyMode = true; // PTY mode sends raw keystrokes, command mode uses line editing

      // =========================================================================
      // WebSocket Connection
      // =========================================================================

      function connect() {
        updateStatus('connecting', 'Connecting to server...');

        // Include terminal size in WebSocket URL
        console.log(`Terminal dimensions at connect time: ${term.cols}x${term.rows}`);
        const wsUrlWithSize = `${WS_URL}?cols=${term.cols}&rows=${term.rows}`;
        console.log('Connecting to WebSocket:', wsUrlWithSize);

        // Show WebSocket URL in status bar
        document.getElementById('ws-url').textContent = WS_URL;

        ws = new WebSocket(wsUrlWithSize);

        ws.onopen = () => {
          updateStatus('connected', 'Connected (PTY mode)');
          console.log('WebSocket connected - PTY mode active');
          console.log('Terminal onData handler:', term.onData ? 'registered' : 'NOT REGISTERED');

          // Focus the terminal
          term.focus();
        };

        ws.onmessage = (event) => {
          // PTY server sends raw text, not JSON
          const data = event.data;
          console.log(
            'WebSocket received:',
            typeof data,
            'length:',
            data?.length,
            'data:',
            JSON.stringify(data?.substring(0, 50))
          );

          // If it's a string (raw PTY output), write directly to terminal
          if (typeof data === 'string') {
            console.log('Writing to terminal:', JSON.stringify(data.substring(0, 50)));
            term.write(data);
          }
          // Otherwise try JSON parsing for file-browser-server compatibility
          else {
            try {
              const jsonData = JSON.parse(data);
              handleServerMessage(jsonData);
            } catch (error) {
              console.error('Failed to parse message:', error);
            }
          }
        };

        ws.onerror = (error) => {
          console.error('WebSocket error:', error);
          updateStatus('error', 'Connection error');
          term?.write('\r\n\x1b[1;31mWebSocket error. Check if server is running.\x1b[0m\r\n');
        };

        ws.onclose = () => {
          updateStatus('disconnected', 'Disconnected');
          console.log('WebSocket closed');
          term?.write('\r\n\x1b[1;33mConnection closed.\x1b[0m\r\n');
        };
      }

      function handleServerMessage(data) {
        switch (data.type) {
          case 'connected':
            currentCwd = data.cwd;
            updateCwdDisplay(currentCwd);
            if (!isPtyMode) {
              showWelcome();
              showPrompt();
            }
            break;

          case 'output':
            // Display stdout
            if (data.stdout) {
              term.write(data.stdout.replace(/\n/g, '\r\n'));
            }

            // Display stderr in red
            if (data.stderr) {
              term.write(`\x1b[1;31m${data.stderr.replace(/\n/g, '\r\n')}\x1b[0m`);
            }

            // Update CWD
            if (data.cwd) {
              currentCwd = data.cwd;
              updateCwdDisplay(currentCwd);
            }

            // Show new prompt
            showPrompt();
            break;

          case 'error':
            term.write(`\r\n\x1b[1;31mError: ${data.data}\x1b[0m\r\n`);
            showPrompt();
            break;
        }
      }

      function sendCommand(command) {
        if (ws && ws.readyState === WebSocket.OPEN) {
          ws.send(
            JSON.stringify({
              type: 'command',
              data: command,
            })
          );

          // Add to history if not empty
          if (command.trim()) {
            commandHistory.push(command);
            historyIndex = commandHistory.length;
          }
        } else {
          term.write('\r\n\x1b[1;31mNot connected to server.\x1b[0m\r\n');
          showPrompt();
        }
      }

      // =========================================================================
      // Terminal UI
      // =========================================================================

      function updateStatus(status, text) {
        const dot = document.getElementById('status-dot');
        const textEl = document.getElementById('status-text');

        dot.className = 'status-dot';
        if (status === 'connected') {
          dot.classList.add('connected');
        }

        textEl.textContent = text;
      }

      function updateCwdDisplay(cwd) {
        const display = document.getElementById('cwd-display');
        // Shorten long paths
        const shortened = cwd.replace(process.env.HOME || '/home/coder', '~');
        display.textContent = shortened;
      }

      function showWelcome() {
        term.write(
          '\x1b[1;36mâ•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—\x1b[0m\r\n'
        );
        term.write(
          '\x1b[1;36mâ•‘\x1b[0m  \x1b[1;32mWelcome to File Browser Terminal!\x1b[0m                       \x1b[1;36mâ•‘\x1b[0m\r\n'
        );
        term.write(
          '\x1b[1;36mâ•‘\x1b[0m                                                              \x1b[1;36mâ•‘\x1b[0m\r\n'
        );
        term.write(
          '\x1b[1;36mâ•‘\x1b[0m  Type commands to navigate your filesystem.                  \x1b[1;36mâ•‘\x1b[0m\r\n'
        );
        term.write(
          '\x1b[1;36mâ•‘\x1b[0m  Try: \x1b[1;33mls -la\x1b[0m, \x1b[1;33mcd /tmp\x1b[0m, \x1b[1;33mcat package.json\x1b[0m            \x1b[1;36mâ•‘\x1b[0m\r\n'
        );
        term.write(
          '\x1b[1;36mâ•‘\x1b[0m                                                              \x1b[1;36mâ•‘\x1b[0m\r\n'
        );
        term.write(
          '\x1b[1;36mâ•‘\x1b[0m  Use â†‘/â†“ for command history, Tab for... well, nothing yet  \x1b[1;36mâ•‘\x1b[0m\r\n'
        );
        term.write(
          '\x1b[1;36mâ•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•\x1b[0m\r\n'
        );
        term.write('\r\n');
      }

      function showPrompt() {
        // Format: user@host:~/path $
        const shortened = currentCwd.replace(process.env.HOME || '/home/coder', '~');
        term.write(`\x1b[1;32m$\x1b[0m `);
        currentLine = '';
      }

      function handleInput(data) {
        console.log(
          'handleInput called, data:',
          data,
          'isPtyMode:',
          isPtyMode,
          'ws state:',
          ws?.readyState
        );

        // PTY mode: send every keystroke directly to shell
        if (isPtyMode) {
          if (ws && ws.readyState === WebSocket.OPEN) {
            console.log('Sending to shell:', JSON.stringify(data));
            ws.send(data);
          } else {
            console.error('WebSocket not open, state:', ws?.readyState);
          }
          return;
        }

        // Command mode: line editing with prompt (for file-browser-server)
        for (let i = 0; i < data.length; i++) {
          const code = data.charCodeAt(i);

          // Enter key
          if (code === 13) {
            term.write('\r\n');
            if (currentLine.trim()) {
              sendCommand(currentLine);
            } else {
              showPrompt();
            }
            currentLine = '';
          }
          // Backspace or Delete
          else if (code === 127 || code === 8) {
            if (currentLine.length > 0) {
              currentLine = currentLine.slice(0, -1);
              term.write('\b \b');
            }
          }
          // Ctrl+C
          else if (code === 3) {
            term.write('^C\r\n');
            currentLine = '';
            showPrompt();
          }
          // Ctrl+D (EOF)
          else if (code === 4) {
            if (currentLine.length === 0) {
              sendCommand('exit');
            }
          }
          // Ctrl+L (clear)
          else if (code === 12) {
            term.clear();
            showPrompt();
          }
          // Arrow Up (previous command)
          else if (code === 27 && data[i + 1] === '[' && data[i + 2] === 'A') {
            if (historyIndex > 0) {
              // Clear current line
              term.write('\r\x1b[K');
              showPrompt();

              // Show previous command
              historyIndex--;
              currentLine = commandHistory[historyIndex];
              term.write(currentLine);
            }
            i += 2; // Skip the rest of the escape sequence
          }
          // Arrow Down (next command)
          else if (code === 27 && data[i + 1] === '[' && data[i + 2] === 'B') {
            // Clear current line
            term.write('\r\x1b[K');
            showPrompt();

            if (historyIndex < commandHistory.length - 1) {
              historyIndex++;
              currentLine = commandHistory[historyIndex];
            } else {
              historyIndex = commandHistory.length;
              currentLine = '';
            }
            term.write(currentLine);
            i += 2; // Skip the rest of the escape sequence
          }
          // Regular printable character
          else if (code >= 32 && code < 127) {
            currentLine += data[i];
            term.write(data[i]);
          }
        }
      }

      // =========================================================================
      // Text Selection Support
      // =========================================================================

      // Text selection is now built-in to the Terminal library!
      // Use term.getSelection() to access selected text programmatically.
      // Features:
      // - Click and drag to select text
      // - Double-click to select a word
      // - Auto-copy to clipboard on selection
      // - Ctrl+C / Cmd+C to copy (via browser context menu)

      // =========================================================================
      // Event Logging & Handlers
      // =========================================================================

      let customHandlerEnabled = false;

      function logEvent(type, data) {
        const eventLog = document.getElementById('event-log');
        const eventDiv = document.createElement('div');
        eventDiv.className = 'event';

        const timestamp = new Date().toLocaleTimeString();
        const dataStr = typeof data === 'object' ? JSON.stringify(data) : String(data);

        eventDiv.innerHTML = `
          <span style="opacity: 0.6;">[${timestamp}]</span> 
          <span class="event-type">${type}:</span> 
          <span class="event-data">${dataStr}</span>
        `;

        eventLog.appendChild(eventDiv);
        eventLog.scrollTop = eventLog.scrollHeight;

        // Keep only last 50 events
        while (eventLog.children.length > 50) {
          eventLog.removeChild(eventLog.firstChild);
        }
      }

      function setupEventHandlers() {
        // Event: onKey - fires on every keypress
        term.onKey((e) => {
          logEvent('onKey', `key="${e.key}" ctrl=${e.domEvent.ctrlKey} alt=${e.domEvent.altKey}`);
        });

        // Event: onTitleChange - fires when terminal title changes via OSC sequences
        term.onTitleChange((title) => {
          logEvent('onTitleChange', title);
          document.title = `${title} - Ghostty Terminal`;
        });

        // Button handlers
        document.getElementById('btn-paste').addEventListener('click', () => {
          term.paste('Pasted text from paste() method!\n');
          logEvent('Action', 'Called paste()');
        });

        document.getElementById('btn-blur').addEventListener('click', () => {
          term.blur();
          logEvent('Action', 'Called blur() - terminal lost focus');
        });

        document.getElementById('btn-input').addEventListener('click', () => {
          term.input('echo "Input from input() method"\n', true);
          logEvent('Action', 'Called input() with wasUserInput=true');
        });

        document.getElementById('btn-select').addEventListener('click', () => {
          // Select 20 characters starting at column 0, row 0
          // This selects from the current cursor position backwards 20 chars
          const cursor = term.wasmTerm.getCursor();
          const startRow = Math.max(0, cursor.y - 1);
          term.select(0, startRow, 30);
          logEvent(
            'Action',
            `Called select(0, ${startRow}, 30) - selects 30 chars from row ${startRow}`
          );
        });

        document.getElementById('btn-selectLines').addEventListener('click', () => {
          // Select last 3 visible lines
          const cursor = term.wasmTerm.getCursor();
          const endRow = cursor.y;
          const startRow = Math.max(0, endRow - 2);
          term.selectLines(startRow, endRow);
          logEvent('Action', `Called selectLines(${startRow}, ${endRow}) - selects 3 lines`);
        });

        document.getElementById('btn-getSelectionPos').addEventListener('click', () => {
          const pos = term.getSelectionPosition();
          if (pos) {
            logEvent(
              'getSelectionPosition',
              `start=(${pos.start.x},${pos.start.y}) end=(${pos.end.x},${pos.end.y})`
            );
          } else {
            logEvent('getSelectionPosition', 'No selection');
          }
        });

        document.getElementById('btn-setTitle').addEventListener('click', () => {
          // Send OSC 2 sequence to change title
          const newTitle = `Ghostty Terminal ${new Date().toLocaleTimeString()}`;
          term.write(`\x1b]2;${newTitle}\x07`);
          logEvent('Action', `Sent OSC 2 sequence with title: ${newTitle}`);
        });

        document.getElementById('btn-customHandler').addEventListener('click', () => {
          customHandlerEnabled = !customHandlerEnabled;

          if (customHandlerEnabled) {
            // Custom handler that blocks Ctrl+K
            term.attachCustomKeyEventHandler((event) => {
              if (event.ctrlKey && event.key === 'k') {
                logEvent('CustomHandler', 'Blocked Ctrl+K');
                return true; // Block default handling
              }
              return false; // Allow default handling
            });
            logEvent('Action', 'Custom handler enabled (blocks Ctrl+K)');
            document.getElementById('btn-customHandler').style.background =
              'rgba(33, 150, 243, 0.8)';
          } else {
            term.attachCustomKeyEventHandler(undefined);
            logEvent('Action', 'Custom handler disabled');
            document.getElementById('btn-customHandler').style.background =
              'rgba(76, 175, 80, 0.8)';
          }
        });

        document.getElementById('btn-clear-log').addEventListener('click', () => {
          document.getElementById('event-log').innerHTML =
            '<div style="opacity: 0.5; text-align: center;">Log cleared</div>';
        });

        // Expose terminal to console for debugging
        window.term = term;
        console.log('Terminal exposed to window.term for debugging');
      }

      // =========================================================================
      // Initialization
      // =========================================================================

      async function init() {
        try {
          // Create terminal with selection enabled
          term = new Terminal({
            cols: 80,
            rows: 30,
            cursorBlink: true,
            theme: {
              background: '#1e1e1e',
              foreground: '#d4d4d4',
              cursor: '#ffffff',
              cursorAccent: '#000000',
              selectionBackground: 'rgba(255, 255, 255, 0.3)',
              selectionForeground: '#ffffff',
              black: '#000000',
              red: '#cd3131',
              green: '#0dbc79',
              yellow: '#e5e510',
              blue: '#2472c8',
              magenta: '#bc3fbc',
              cyan: '#11a8cd',
              white: '#e5e5e5',
              brightBlack: '#666666',
              brightRed: '#f14c4c',
              brightGreen: '#23d18b',
              brightYellow: '#f5f543',
              brightBlue: '#3b8eea',
              brightMagenta: '#d670d6',
              brightCyan: '#29b8db',
              brightWhite: '#ffffff',
            },
            fontFamily: "'Monaco', 'Menlo', 'Consolas', 'Courier New', monospace",
            fontSize: 14,
            scrollback: 10000,
          });

          // Create FitAddon
          fitAddon = new FitAddon();
          term.loadAddon(fitAddon);

          // Open terminal
          const container = document.getElementById('terminal-container');
          await term.open(container);

          // Fit terminal to container
          fitAddon.fit();
          console.log(`After fit(): Terminal size is ${term.cols}x${term.rows}`);

          // Handle window resize
          window.addEventListener('resize', () => {
            fitAddon.fit();
          });

          // Send resize notifications to server
          term.onResize(({ cols, rows }) => {
            if (ws && ws.readyState === WebSocket.OPEN) {
              ws.send(JSON.stringify({ type: 'resize', cols, rows }));
              console.log(`Sent resize to server: ${cols}x${rows}`);
            }
          });

          // Handle input
          term.onData(handleInput);

          // Text selection is now built-in - no need to enable it!
          // You can use term.getSelection(), term.selectAll(), etc.

          // Hook up event listeners and test buttons
          setupEventHandlers();

          // Connect to WebSocket server
          connect();
        } catch (error) {
          console.error('Failed to initialize terminal:', error);
          updateStatus('error', 'Initialization failed');
        }
      }

      // Start when page loads
      init();
    </script>
  </body>
</html>
